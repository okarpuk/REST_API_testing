
========================================================= JSON Schema ========================================================================


JSON SCHEMA — это ДОКУМЕНТ, который описывает КАКИМ ДОЛЖЕН БЫТЬ JSON при отправке запроса / получении ответа от сервера.

JSON Schema ВЫГЛЯДИТ ТАКЖЕ, как и JSON. В нём используется ТОТ ЖЕ СИНТАКСИС и те же типы данных. JSON Schema также оборачивается в фигурные скобки.

В целом, JSON Schema служит для ПРОВЕРКИ КОРРЕКТНОСТИ ОТВЕТА сервера (валидации).
Она проверяет полученный JSON на наличие правильных данных, соответствующих типов данных, а убеждается в наличии всех обязательных полей и т. д.

Основные КЛЮЧЕВЫЕ СЛОВА в JSON Schema:
	- TYPE - для определения типа данных поля или объекта.
	- PROPERTIES - для перечисления возможных полей в JSON и определения требования к ним.
	- ITEMS - для описания требований к массиву.
	- REQUIRED - для перечисления обязательных полей в JSON.
	- ENUM - для перечисления возможных значений у конкретного поля.


************************************************************* TYPE ***************************************************************************

Ключевое слово TYPE используется для ОПРЕДЕЛЕНИЯ ТИПА ДАННЫХ у поля или объекта.

К примеру, дан JSON:
	{
    	"name": "Alex"
	}


Для валидации данного JSON воспользуемся следующей JSON SCHEMA:
	{
    	"type": "object",                // документ, который мы валидируем является JSON, т.е. объект 
    	"properties": {                  // properties, служит для перечисления возможных полей в JSON
        	"name": {"type": "string"}   // ожидается, что у поля name, ТИП данных будет STRING
    	}
	}


1) Объявляем "type": "object", чтобы валидатор понимал, что проверяемый данный документ ЯВЛЯЕТСЯ ОБЪЕКТОМ.
2) В properties перечисляются ПОЛЯ, которые могут присутствовать в JSON.
   Здесь мы записали поле name и выставили требование к полю {"type": "string"} означающее, что поле name может являться ТОЛЬКО STRING.
   Значением поля name является вложенный объект {"type": "string"}. Внутри данного вложенного объекта выставляются требования к полю name.


У ключевого слова TYPE, могут быть следующие ЗНАЧЕНИЯ:
	- {"type": "string"} - поле должно являться строкой.
	- {"type": "number"} - поле должно являться числом.
	- {"type": "integer"} - поле должно являться целым числом.
	- {"type": "array"} - поле должно являться массивом.
	- {"type": "boolean"} - поле должно являться булевым значением.
	- {"type": "null"} - поле должно являться null.
	- {"type": "object"} - поле должно являться объектом.

Для объявления НЕСКОЛЬКИХ ДОПУСТИМЫХ ТИПОВ данных для одного поля, используется следующий синтаксис:
	{"type": ["string", "null"]}.

В этом случае значением поля type является МАССИВ С перечисленными возможными ТИПАМИ данных для поля.



************************************************************* PROPERTIES ***************************************************************************

Ключевое слово PROPERTIES используется для перечисления ВОЗМОЖНЫХ ПОЛЕЙ в JSON и для выставления ТРЕБОВАНИЙ к этим полям.

ЗНАЧЕНИЕМ поля properties является ВЛОЖЕННЫЙ ОБЪЕКТ, в котором перечислены ПОЛЯ и ТРЕБОВАНИЯ к ним, которые могут присутствовать в JSON.

К примеру, дан JSON:
{
    "name": "Leonardo",
    "age": 47
}

Для валидации данного JSON воспользуемся следующей JSON SCHEMA:
{
    "type": "object",
    "properties": {
        "name": {"type": "string"},
        "age": {"type": ["integer", "null"]}
    }
}

В этом примере описано, что в JSON могут присутствовать поля:
	- NAME, значением у которого должна быть STRING (строка).
	- AGE, значением у которого должны быть либо INTEGER (целые числа), либо NULL.



************************************************************* REQUIRED ***************************************************************************

Ключевое слово REQUIRED используется для перечисления ОБЯЗАТЕЛЬНЫХ ПОЛЕЙ в JSON 

К примеру, дан JSON:
{
    "name": "Alex"
}

Для определения поля NAME как ОБЯЗАТЕЛЬНОГО, мы можем использовать ключевое слово required.
ЗНАЧЕНИЕМ поля required ВСЕГДА является МАССИВ, в котором ПЕРЕЧИСЛЯЮТСЯ обязательные поля через запятую.
{
    "type": "object",
    "required": [
        "name"
    ]
}


В комбинации с properties наша JSON SCHEMA могла бы выглядеть следующим образом:
{
    "type": "object",
    "properties": {                  
        "name": {"type": "string"}
    },
    "required": [
        "name"
    ]
}

В PROPERTIES мы выставили ТРЕБОВАНИЯ к полю name указав, что поле может являться только строкой.
А в REQUIRED определили данное поле как ОБЯЗАТЕЛЬНОЕ.


Если в JSON будет отсутствовать поле name или если значение поля не будет являться строкой - мы ПОЛУЧИМ ОШИБКУ валидации.

Примечания:
	1) Если используется required, но НЕ УКАЗАНО соответствующее СВОЙСТВО в properties,
	   JSON все равно ДОЛЖЕН СОДЕРЖАТЬ это обязательное ПОЛЕ для успешной валидации, но у Вас НЕ БУДУТ УСТАНОВЛЕНЫ специфические ТРЕБОВАНИЯ к данному полю.
	   
	2) Если свойство не указано в required, то его наличие в JSON является НЕОБЯЗАТЕЛЬНЫМ.
	   Тем не менее, ЕСЛИ оно ПРИСУТСТВУЕТ, его значение ДОЛЖНО СООТВЕТСТВОВАТЬ описанию из properties.



************************************************************* ITEMS ***************************************************************************

Ключевое слово ITEMS используется для выставления ТРЕБОВАНИЙ К ЭЛЕМЕНТАМ массива.

Для примера. Дан JSON:
{
    "users": [
        "Alex",
        "Vasiliy",
        "Petr"
    ]
}

Составим JSON Schema:
{
    "type": "object",
    "properties": {
        "users": {
            "type": "array",
            "items": {
                "type": "string"
            }
        }
    }
}

	- "type": "array" указывает на то, что ПОЛЕ users должно являться МАССИВОМ.
	- "items": {"type": "string"} указывает на то, что ЭЛЕМЕНТАМИ массива должны являться СТРОКИ.


Довольно часто в JSON, МАССИВЫ СОДЕРЖАТ ОБЪЕКТЫ.

К примеру, дан JSON:
{
    "users": [
        {
            "userId": 1,
            "name": "David"
        },
        {
            "userId": 2,
            "name": "Alex"
        }
    ]
}

Значением ключа users является массив состоящий из объектов.

Составим JSON Schema:
{
    "type": "object",
    "properties": {
        "users": {
            "type": "array",
            "items": {
                "type": "object",
                "properties": {
                    "userId": {
                        "type": "integer"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "required": [
                    "name"
                ]
            }
        }
    }
}

В items описываются какими должны быть элементы внутри массива. Ожидается, что внутри массива элементами будут объекты (JSON). 

Рассмотрим КАКИМИ ДОЛЖНЫ БЫТЬ объекты внутри массива users, согласно составленной схеме.
	- "type": "object" - элементами массива users, должны быть объекты.
	- "properties": {"userId": {"type": "integer"}, "name": {"type": "string"}} - значением поля "properties" является вложенный объект, в которым выставлены требования к ключам userId и name:
	- поле userId должно являться целым числом;
	- поле name должно являться строкой.
	- "required": [ "name" ] здесь перечислены обязательные ключи, которые должны присутствовать в объекте, находящемся внутри массива users.

Таким образом, в items мы можем описать какими должны быть элементы массива. В случае ЕСЛИ ЭЛЕМЕНТАМИ массива должны являться ОБЪЕКТЫ,
мы описываем эти объекты в items, как и обычные объекты.

Мы рассмотрели вариант описания поля items со значением в виде вложенного объекта.
Данный способ является предпочтительным в случае, когда мы хотим описать, как должен выглядеть каждый элемент массива.
Но если нужно описать каждый элемент отдельно, значением items может являться массив.

К примеру, дан JSON:
{
    "myArray": ["hello", true, 25]
}

По требованиям:
	- первый элемент массива должен являться строкой;
	- второй элемент массива должен являться булевым значением;
	- третий элемент массива должен являться целым числом.

Опишем схему, согласно требованиям:
{
    "type": "object",
    "properties": {
        "myArray": {
            "type": "array",
            "items": [
                {
                    "type": "string"
                },
                {
                    "type": "boolean"
                },
                {
                    "type": "integer"
                }
            ]
        }
    }
}

В данном примере значением items является массив. В этом массиве перечисляется требования к каждому элементу массива через запятую:
	- {"type": "string"} - первый элемент массива должен являться строкой.
	- {"type": "boolean"} - второй элемент массива должен являться булевым значением.
	- {"type": "integer"} - третий элемент массива должен являться целым числом.



************************************************************* ENUM ***************************************************************************

Ключевое слово ENUM используется для ПЕРЕЧИСЛЕНИЯ ДОПУСТИМЫХ ЗНАЧЕНИЙ в поле.

К примеру, дан JSON:
{
    "name": "Petr",
    "gender": "male"
}

Согласно требованиям поле gender может являться либо male, либо female.
Также данное поле является необязательным, поэтому в нем также может быть значение null.

Опишем схему:
{
    "type": "object",
    "properties": {
        "name": {
            "type": "string"
        },
        "gender": {
            "type": [
                "string",
                "null"
            ],
            "enum": [
                "male",
                "female",
                null
            ]
        }
    }
}

В схеме, для поля gender ВЫСТАВЛЕНЫ следующие ТРЕБОВАНИЯ:
	- Типом данных может являться либо строка, либо null.
	- Поле gender может хранить значения male, female, null.

Обратите внимание: в type мы указали "null" в кавычках, т. к. поле в поле type определяются возможные типы данных для поля
и ранее в уроке мы рассмотрели возможные значения для поля type.

В свою очередь в enum перечисляются конкретные значения в том виде, в котором они будут представлены в JSON.
Таким образом если в enum передать "null" вместо null, валидатор будет ожидать строку со значением "null", вместо литерала null.

В enum, по аналогии с null, перечисляются и остальные типы данных в том же виде, в котором они будут представлены в JSON.


ИТОГ:
	- Значением поля enum всегда является массив, в котором перечисляются возможные значения поля.
	 -В enum возможные значения поля всегда перечисляются в том виде, в котором они будут представлены в JSON.
	 -Не забывайте указывать null в enum, если поле является необязательным.



















